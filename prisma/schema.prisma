generator client {
  provider = "prisma-client-js"
}

generator erd {
  provider = "prisma-erd-generator"
  output   = "./ERD.svg"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  fullname     String
  clerkId      String     @unique
  type         String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  stripeId     String?
  subscription Billings?
  campaign     Campaign[]
  domains      Domain[]
}

model Domain {
  id              String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String
  icon            String
  userId          String?           @db.Uuid
  campaignId      String?           @db.Uuid
  chatBot         ChatBot?
  customer        Customer[]
  Campaign        Campaign?         @relation(fields: [campaignId], references: [id])
  User            User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  filterQuestions FilterQuestions[]
  helpdesk        HelpDesk[]
  products        Product[]
  availability    AvailabilitySchedule[]
}

model ChatBot {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  welcomeMessage String?
  icon           String?
  background     String?
  textColor      String?
  helpdesk       Boolean @default(false)
  domainId       String? @unique @db.Uuid
  Domain         Domain? @relation(fields: [domainId], references: [id], onDelete: Cascade)
}

model Billings {
  id      String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  plan    Plans   @default(STANDARD)
  credits Int     @default(10)
  userId  String? @unique @db.Uuid
  User    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model HelpDesk {
  id       String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  question String
  answer   String
  domainId String? @db.Uuid
  Domain   Domain? @relation(fields: [domainId], references: [id], onDelete: Cascade)
}

model FilterQuestions {
  id       String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  question String
  answered String?
  domainId String? @db.Uuid
  Domain   Domain? @relation(fields: [domainId], references: [id], onDelete: Cascade)
}

model CustomerResponses {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  question   String
  answered   String?
  customerId String   @db.Uuid
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model Customer {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name              String?
  email             String?
  phone             String?
  status            Boolean   @default(true)
  totalInteractions Int       @default(0)
  lastActiveAt      DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  questions CustomerResponses[]
  chatRoom  ChatRoom[]
  booking   Bookings[]
  satisfactionRecords CustomerSatisfaction[]

  Domain   Domain? @relation(fields: [domainId], references: [id], onDelete: Cascade)
  domainId String? @db.Uuid
}

model ChatRoom {
  id         String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  live       Boolean       @default(false)
  mailed     Boolean       @default(false)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  customerId String?       @db.Uuid
  
  // Sistema de favoritos
  isFavorite                Boolean               @default(false)
  
  // Métricas para la tesis - FR3 y FR4
  resolved                    Boolean               @default(false)
  resolvedInFirstInteraction  Boolean?
  resolutionType              ResolutionType        @default(UNRESOLVED)
  satisfactionRating          Int?                  // 1-5, null si no ha evaluado
  satisfactionCollected       Boolean               @default(false)
  conversationEndedAt         DateTime?
  
  // Estado de conversación y gestión de ciclo de vida
  conversationState           ConversationState     @default(ACTIVE)
  lastUserActivityAt          DateTime              @default(now())
  conversationNumber          Int                   @default(1) // Número de conversación con este cliente
  
  message              ChatMessage[]
  metrics              ConversationMetrics[]
  satisfactionRecords  CustomerSatisfaction[]
  Customer             Customer?             @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  message    String
  role       Role?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  chatRoomId String?   @db.Uuid
  seen       Boolean   @default(false)
  
  // Métricas para la tesis - FR1 y FR2
  responseTime           Int?     // Tiempo en segundos desde mensaje user hasta respuesta assistant
  respondedWithin2Hours  Boolean? // True si fue respondido en menos de 2 horas
  
  ChatRoom   ChatRoom? @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
}

model Bookings {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  date       DateTime
  slot       String
  email      String
  customerId String?   @db.Uuid
  domainId   String?   @db.Uuid
  createdAt  DateTime  @default(now())
  Customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model Campaign {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  customers String[]
  template  String?
  userId    String?  @db.Uuid
  createdAt DateTime @default(now())
  User      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  domain    Domain[]
}

model Product {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  price     Int
  image     String
  createdAt DateTime @default(now())
  domainId  String?  @db.Uuid
  active    Boolean  @default(true)
  Domain    Domain?  @relation(fields: [domainId], references: [id], onDelete: Cascade)
}

model AvailabilitySchedule {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  dayOfWeek DayOfWeek
  timeSlots String[]  // Array de strings como ["9:00am", "9:30am", "10:00am"]
  isActive  Boolean  @default(true)
  domainId  String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Domain    Domain   @relation(fields: [domainId], references: [id], onDelete: Cascade)
  
  @@unique([domainId, dayOfWeek])
}

// Nuevos modelos para métricas de tesis
model ConversationMetrics {
  id                    String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chatRoomId            String   @db.Uuid
  domainId              String   @db.Uuid
  
  // FR1: Tiempo promedio de respuesta
  averageResponseTime   Int      // En segundos
  totalResponseTime     Int      // Suma total para calcular promedio
  messagesCount         Int      // Total de intercambios
  
  // FR2: Porcentaje de mensajes respondidos oportunamente
  messagesRespondedOnTime Int    // Mensajes respondidos < 2 horas
  totalMessagesReceived   Int    // Total de mensajes del usuario
  percentageOnTime        Decimal @db.Decimal(5,2)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
}

// FR4: Satisfacción del cliente
model CustomerSatisfaction {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  rating     Int      // 1-5
  comment    String?  // Comentario opcional del cliente
  chatRoomId String   @db.Uuid
  customerId String   @db.Uuid
  domainId   String   @db.Uuid
  createdAt  DateTime @default(now())
  
  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@index([domainId])
  @@index([createdAt])
}

enum Role {
  user
  assistant
}

enum Plans {
  STANDARD
  PRO
  ULTIMATE
}

// FR3: Tipo de resolución
enum ResolutionType {
  FIRST_INTERACTION  // Resuelto en primera interacción
  FOLLOW_UP          // Requirió seguimiento
  ESCALATED          // Escalado a humano
  UNRESOLVED         // No resuelto aún
}

// Estado del ciclo de vida de la conversación
enum ConversationState {
  ACTIVE      // Conversación activa (usuario interactuando)
  IDLE        // Usuario inactivo (>5 minutos sin responder)
  AWAITING_RATING  // Esperando calificación del usuario
  ENDED       // Conversación finalizada (calificada o despedida)
}

// Días de la semana para disponibilidad
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}
